# Copyright 2024-2025 AI Whisperers (https://github.com/Ai-Whisperers)
#
# Licensed under the PolyForm Noncommercial License 1.0.0
# See LICENSE file in the repository root for full license text.

"""Automated Clinical Report Generator.

Generates PDF and HTML clinical reports for drug resistance analysis,
similar to Stanford HIVdb reports.

Features:
- Template-based report generation
- PDF and HTML output formats
- Customizable branding and styling
- Multi-language support (English, Spanish, French)
- Report versioning and archival
- Integration with API for automated report delivery

Usage:
    from src.clinical.report_generator import ReportGenerator

    generator = ReportGenerator()
    report = generator.generate(
        patient_id="P001",
        sequence="MKWVTVY...",
        predictions=predictions,
        output_format="pdf",
    )
"""

from __future__ import annotations

import json
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional
import html
import io


class ReportFormat(Enum):
    """Supported report output formats."""
    HTML = "html"
    PDF = "pdf"
    JSON = "json"


class ReportLanguage(Enum):
    """Supported report languages."""
    ENGLISH = "en"
    SPANISH = "es"
    FRENCH = "fr"


@dataclass
class DrugPrediction:
    """Drug resistance prediction for report."""
    drug_name: str
    drug_class: str
    resistance_score: float
    classification: str  # susceptible, intermediate, resistant
    confidence: float
    mutations: List[str] = field(default_factory=list)
    interpretation: str = ""


@dataclass
class ReportConfig:
    """Configuration for report generation."""
    format: ReportFormat = ReportFormat.HTML
    language: ReportLanguage = ReportLanguage.ENGLISH
    include_logo: bool = True
    include_mutations: bool = True
    include_interpretation: bool = True
    include_recommendations: bool = True
    custom_header: Optional[str] = None
    custom_footer: Optional[str] = None
    organization_name: str = "P-adic VAE Drug Resistance Prediction"
    report_version: str = "1.0"


@dataclass
class ResistanceReport:
    """Complete drug resistance report."""
    report_id: str
    patient_id: Optional[str]
    sequence_length: int
    analysis_date: datetime
    disease: str
    predictions: List[DrugPrediction]
    recommended_drugs: List[str]
    avoid_drugs: List[str]
    warnings: List[str]
    overall_recommendation: str
    mutations_detected: List[Dict[str, Any]]
    config: ReportConfig
    raw_sequence: str = ""


# Translation dictionaries
TRANSLATIONS = {
    ReportLanguage.ENGLISH: {
        "title": "Drug Resistance Analysis Report",
        "patient_id": "Patient ID",
        "sequence_length": "Sequence Length",
        "analysis_date": "Analysis Date",
        "disease": "Disease",
        "drug_resistance": "Drug Resistance Predictions",
        "drug": "Drug",
        "class": "Class",
        "score": "Score",
        "classification": "Classification",
        "confidence": "Confidence",
        "mutations": "Mutations",
        "interpretation": "Interpretation",
        "recommendations": "Treatment Recommendations",
        "recommended": "Recommended Drugs",
        "avoid": "Drugs to Avoid",
        "warnings": "Clinical Warnings",
        "overall": "Overall Recommendation",
        "susceptible": "Susceptible",
        "intermediate": "Intermediate",
        "resistant": "Resistant",
        "high_resistance": "High Resistance",
        "low_resistance": "Low Resistance",
        "footer": "This report is for research purposes only. Clinical decisions should involve a qualified physician.",
        "generated_by": "Generated by",
        "report_version": "Report Version",
    },
    ReportLanguage.SPANISH: {
        "title": "Informe de Analisis de Resistencia a Medicamentos",
        "patient_id": "ID del Paciente",
        "sequence_length": "Longitud de Secuencia",
        "analysis_date": "Fecha de Analisis",
        "disease": "Enfermedad",
        "drug_resistance": "Predicciones de Resistencia",
        "drug": "Medicamento",
        "class": "Clase",
        "score": "Puntuacion",
        "classification": "Clasificacion",
        "confidence": "Confianza",
        "mutations": "Mutaciones",
        "interpretation": "Interpretacion",
        "recommendations": "Recomendaciones de Tratamiento",
        "recommended": "Medicamentos Recomendados",
        "avoid": "Medicamentos a Evitar",
        "warnings": "Advertencias Clinicas",
        "overall": "Recomendacion General",
        "susceptible": "Susceptible",
        "intermediate": "Intermedio",
        "resistant": "Resistente",
        "high_resistance": "Alta Resistencia",
        "low_resistance": "Baja Resistencia",
        "footer": "Este informe es solo para fines de investigacion.",
        "generated_by": "Generado por",
        "report_version": "Version del Informe",
    },
    ReportLanguage.FRENCH: {
        "title": "Rapport d'Analyse de Resistance aux Medicaments",
        "patient_id": "ID Patient",
        "sequence_length": "Longueur de Sequence",
        "analysis_date": "Date d'Analyse",
        "disease": "Maladie",
        "drug_resistance": "Predictions de Resistance",
        "drug": "Medicament",
        "class": "Classe",
        "score": "Score",
        "classification": "Classification",
        "confidence": "Confiance",
        "mutations": "Mutations",
        "interpretation": "Interpretation",
        "recommendations": "Recommandations de Traitement",
        "recommended": "Medicaments Recommandes",
        "avoid": "Medicaments a Eviter",
        "warnings": "Avertissements Cliniques",
        "overall": "Recommandation Generale",
        "susceptible": "Sensible",
        "intermediate": "Intermediaire",
        "resistant": "Resistant",
        "high_resistance": "Haute Resistance",
        "low_resistance": "Faible Resistance",
        "footer": "Ce rapport est a des fins de recherche uniquement.",
        "generated_by": "Genere par",
        "report_version": "Version du Rapport",
    },
}


class BaseReportRenderer(ABC):
    """Abstract base class for report renderers."""

    def __init__(self, config: ReportConfig):
        self.config = config
        self.translations = TRANSLATIONS[config.language]

    def t(self, key: str) -> str:
        """Translate a key to the configured language."""
        return self.translations.get(key, key)

    @abstractmethod
    def render(self, report: ResistanceReport) -> bytes:
        """Render the report to the output format."""
        pass


class HTMLReportRenderer(BaseReportRenderer):
    """Render reports as HTML."""

    def _get_resistance_color(self, classification: str) -> str:
        """Get color based on resistance classification."""
        colors = {
            "susceptible": "#28a745",  # Green
            "low_resistance": "#6c757d",  # Gray
            "intermediate": "#ffc107",  # Yellow
            "resistant": "#fd7e14",  # Orange
            "high_resistance": "#dc3545",  # Red
        }
        return colors.get(classification.lower().replace(" ", "_"), "#6c757d")

    def _get_resistance_bar(self, score: float) -> str:
        """Generate a visual bar for resistance score."""
        percentage = int(score * 100)
        if score < 0.3:
            color = "#28a745"
        elif score < 0.5:
            color = "#ffc107"
        elif score < 0.7:
            color = "#fd7e14"
        else:
            color = "#dc3545"

        return f'''
        <div style="background: #e9ecef; border-radius: 4px; height: 20px; width: 100px; display: inline-block; vertical-align: middle;">
            <div style="background: {color}; height: 100%; width: {percentage}%; border-radius: 4px;"></div>
        </div>
        <span style="margin-left: 8px;">{percentage}%</span>
        '''

    def render(self, report: ResistanceReport) -> bytes:
        """Render report as HTML."""
        # Group predictions by drug class
        by_class: Dict[str, List[DrugPrediction]] = {}
        for pred in report.predictions:
            drug_class = pred.drug_class.upper()
            if drug_class not in by_class:
                by_class[drug_class] = []
            by_class[drug_class].append(pred)

        # Build HTML
        html_content = f'''<!DOCTYPE html>
<html lang="{self.config.language.value}">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{self.t("title")} - {report.patient_id or report.report_id}</title>
    <style>
        body {{
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background: #f8f9fa;
        }}
        .report-container {{
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 30px;
        }}
        .header {{
            border-bottom: 2px solid #007bff;
            padding-bottom: 20px;
            margin-bottom: 20px;
        }}
        .header h1 {{
            color: #007bff;
            margin: 0;
            font-size: 24px;
        }}
        .header .org-name {{
            color: #6c757d;
            font-size: 14px;
            margin-top: 5px;
        }}
        .meta-info {{
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }}
        .meta-item {{
            display: flex;
            flex-direction: column;
        }}
        .meta-label {{
            font-size: 12px;
            color: #6c757d;
            text-transform: uppercase;
        }}
        .meta-value {{
            font-size: 16px;
            font-weight: 500;
        }}
        .section {{
            margin-bottom: 25px;
        }}
        .section h2 {{
            color: #495057;
            font-size: 18px;
            border-bottom: 1px solid #dee2e6;
            padding-bottom: 10px;
            margin-bottom: 15px;
        }}
        .drug-class {{
            margin-bottom: 20px;
        }}
        .drug-class h3 {{
            color: #007bff;
            font-size: 16px;
            margin-bottom: 10px;
        }}
        table {{
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 15px;
        }}
        th, td {{
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #dee2e6;
        }}
        th {{
            background: #f8f9fa;
            font-weight: 600;
            font-size: 13px;
            text-transform: uppercase;
            color: #6c757d;
        }}
        .badge {{
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
        }}
        .badge-success {{ background: #d4edda; color: #155724; }}
        .badge-warning {{ background: #fff3cd; color: #856404; }}
        .badge-danger {{ background: #f8d7da; color: #721c24; }}
        .recommendations {{
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }}
        .rec-box {{
            padding: 15px;
            border-radius: 8px;
        }}
        .rec-box.recommended {{
            background: #d4edda;
            border: 1px solid #c3e6cb;
        }}
        .rec-box.avoid {{
            background: #f8d7da;
            border: 1px solid #f5c6cb;
        }}
        .rec-box h4 {{
            margin: 0 0 10px 0;
            font-size: 14px;
        }}
        .rec-box ul {{
            margin: 0;
            padding-left: 20px;
        }}
        .warnings {{
            background: #fff3cd;
            border: 1px solid #ffeeba;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }}
        .warnings h4 {{
            color: #856404;
            margin: 0 0 10px 0;
        }}
        .overall {{
            background: #e9ecef;
            border-radius: 8px;
            padding: 15px;
            font-size: 16px;
        }}
        .footer {{
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #dee2e6;
            font-size: 12px;
            color: #6c757d;
            text-align: center;
        }}
        @media print {{
            body {{
                background: white;
                padding: 0;
            }}
            .report-container {{
                box-shadow: none;
            }}
        }}
    </style>
</head>
<body>
    <div class="report-container">
        <div class="header">
            <h1>{self.t("title")}</h1>
            <div class="org-name">{html.escape(self.config.organization_name)}</div>
        </div>

        <div class="meta-info">
            <div class="meta-item">
                <span class="meta-label">{self.t("patient_id")}</span>
                <span class="meta-value">{html.escape(report.patient_id or 'N/A')}</span>
            </div>
            <div class="meta-item">
                <span class="meta-label">{self.t("disease")}</span>
                <span class="meta-value">{html.escape(report.disease.upper())}</span>
            </div>
            <div class="meta-item">
                <span class="meta-label">{self.t("sequence_length")}</span>
                <span class="meta-value">{report.sequence_length} aa</span>
            </div>
            <div class="meta-item">
                <span class="meta-label">{self.t("analysis_date")}</span>
                <span class="meta-value">{report.analysis_date.strftime("%Y-%m-%d %H:%M")}</span>
            </div>
        </div>

        <div class="section">
            <h2>{self.t("drug_resistance")}</h2>
'''

        # Add drug tables by class
        for drug_class, predictions in by_class.items():
            html_content += f'''
            <div class="drug-class">
                <h3>{drug_class}</h3>
                <table>
                    <thead>
                        <tr>
                            <th>{self.t("drug")}</th>
                            <th>{self.t("score")}</th>
                            <th>{self.t("classification")}</th>
                            <th>{self.t("confidence")}</th>
'''
            if self.config.include_mutations:
                html_content += f'                            <th>{self.t("mutations")}</th>\n'
            html_content += '''                        </tr>
                    </thead>
                    <tbody>
'''

            for pred in sorted(predictions, key=lambda p: -p.resistance_score):
                badge_class = "success" if pred.classification == "susceptible" else (
                    "warning" if pred.classification == "intermediate" else "danger"
                )
                classification_display = self.t(pred.classification.lower().replace(" ", "_"))

                html_content += f'''                        <tr>
                            <td><strong>{html.escape(pred.drug_name)}</strong></td>
                            <td>{self._get_resistance_bar(pred.resistance_score)}</td>
                            <td><span class="badge badge-{badge_class}">{classification_display}</span></td>
                            <td>{pred.confidence * 100:.1f}%</td>
'''
                if self.config.include_mutations:
                    mutations = ", ".join(pred.mutations) if pred.mutations else "-"
                    html_content += f'                            <td>{html.escape(mutations)}</td>\n'
                html_content += '                        </tr>\n'

            html_content += '''                    </tbody>
                </table>
            </div>
'''

        # Add warnings if any
        if report.warnings and self.config.include_interpretation:
            html_content += f'''
        <div class="warnings">
            <h4>{self.t("warnings")}</h4>
            <ul>
'''
            for warning in report.warnings:
                html_content += f'                <li>{html.escape(warning)}</li>\n'
            html_content += '''            </ul>
        </div>
'''

        # Add recommendations
        if self.config.include_recommendations:
            html_content += f'''
        <div class="section">
            <h2>{self.t("recommendations")}</h2>
            <div class="recommendations">
                <div class="rec-box recommended">
                    <h4>{self.t("recommended")}</h4>
                    <ul>
'''
            for drug in report.recommended_drugs[:10]:  # Limit to top 10
                html_content += f'                        <li>{html.escape(drug)}</li>\n'
            if not report.recommended_drugs:
                html_content += '                        <li>-</li>\n'

            html_content += f'''                    </ul>
                </div>
                <div class="rec-box avoid">
                    <h4>{self.t("avoid")}</h4>
                    <ul>
'''
            for drug in report.avoid_drugs[:10]:  # Limit to top 10
                html_content += f'                        <li>{html.escape(drug)}</li>\n'
            if not report.avoid_drugs:
                html_content += '                        <li>-</li>\n'

            html_content += '''                    </ul>
                </div>
            </div>
        </div>
'''

        # Add overall recommendation
        html_content += f'''
        <div class="section">
            <h2>{self.t("overall")}</h2>
            <div class="overall">
                {html.escape(report.overall_recommendation)}
            </div>
        </div>

        <div class="footer">
            <p>{self.t("footer")}</p>
            <p>{self.t("generated_by")}: {html.escape(self.config.organization_name)} |
               {self.t("report_version")}: {self.config.report_version} |
               Report ID: {report.report_id}</p>
        </div>
    </div>
</body>
</html>'''

        return html_content.encode("utf-8")


class PDFReportRenderer(BaseReportRenderer):
    """Render reports as PDF (requires weasyprint or similar)."""

    def render(self, report: ResistanceReport) -> bytes:
        """Render report as PDF using HTML-to-PDF conversion."""
        # First generate HTML
        html_renderer = HTMLReportRenderer(self.config)
        html_content = html_renderer.render(report)

        # Try to use weasyprint for PDF conversion
        try:
            from weasyprint import HTML
            pdf_bytes = HTML(string=html_content.decode("utf-8")).write_pdf()
            return pdf_bytes
        except ImportError:
            # Fall back to returning HTML with a note
            # In production, you would want to use a proper PDF library
            warning = b"<!-- PDF generation requires weasyprint: pip install weasyprint -->\n"
            return warning + html_content


class JSONReportRenderer(BaseReportRenderer):
    """Render reports as JSON for API consumption."""

    def render(self, report: ResistanceReport) -> bytes:
        """Render report as JSON."""
        data = {
            "report_id": report.report_id,
            "patient_id": report.patient_id,
            "sequence_length": report.sequence_length,
            "analysis_date": report.analysis_date.isoformat(),
            "disease": report.disease,
            "predictions": [
                {
                    "drug_name": p.drug_name,
                    "drug_class": p.drug_class,
                    "resistance_score": p.resistance_score,
                    "classification": p.classification,
                    "confidence": p.confidence,
                    "mutations": p.mutations,
                    "interpretation": p.interpretation,
                }
                for p in report.predictions
            ],
            "recommended_drugs": report.recommended_drugs,
            "avoid_drugs": report.avoid_drugs,
            "warnings": report.warnings,
            "overall_recommendation": report.overall_recommendation,
            "mutations_detected": report.mutations_detected,
            "config": {
                "format": report.config.format.value,
                "language": report.config.language.value,
                "organization_name": report.config.organization_name,
                "report_version": report.config.report_version,
            },
        }
        return json.dumps(data, indent=2).encode("utf-8")


class ReportGenerator:
    """Main report generator class."""

    def __init__(self, config: Optional[ReportConfig] = None):
        """Initialize the report generator.

        Args:
            config: Report configuration (uses defaults if None)
        """
        self.config = config or ReportConfig()
        self._renderers = {
            ReportFormat.HTML: HTMLReportRenderer,
            ReportFormat.PDF: PDFReportRenderer,
            ReportFormat.JSON: JSONReportRenderer,
        }

    def _generate_report_id(self) -> str:
        """Generate a unique report ID."""
        from datetime import datetime
        import random
        timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
        random_suffix = random.randint(1000, 9999)
        return f"RPT-{timestamp}-{random_suffix}"

    def generate(
        self,
        sequence: str,
        predictions: List[DrugPrediction],
        disease: str = "HIV",
        patient_id: Optional[str] = None,
        recommended_drugs: Optional[List[str]] = None,
        avoid_drugs: Optional[List[str]] = None,
        warnings: Optional[List[str]] = None,
        overall_recommendation: str = "",
        mutations_detected: Optional[List[Dict[str, Any]]] = None,
        output_format: Optional[ReportFormat] = None,
    ) -> bytes:
        """Generate a clinical report.

        Args:
            sequence: The analyzed sequence
            predictions: List of drug predictions
            disease: Disease type
            patient_id: Optional patient identifier
            recommended_drugs: List of recommended drugs
            avoid_drugs: List of drugs to avoid
            warnings: Clinical warnings
            overall_recommendation: Overall treatment recommendation
            mutations_detected: Detected mutations
            output_format: Output format (overrides config)

        Returns:
            Report content as bytes
        """
        report_format = output_format or self.config.format

        # Create report object
        report = ResistanceReport(
            report_id=self._generate_report_id(),
            patient_id=patient_id,
            sequence_length=len(sequence),
            analysis_date=datetime.now(),
            disease=disease,
            predictions=predictions,
            recommended_drugs=recommended_drugs or [],
            avoid_drugs=avoid_drugs or [],
            warnings=warnings or [],
            overall_recommendation=overall_recommendation or "See drug-specific predictions above.",
            mutations_detected=mutations_detected or [],
            config=self.config,
            raw_sequence=sequence,
        )

        # Get appropriate renderer
        renderer_class = self._renderers.get(report_format, HTMLReportRenderer)
        renderer = renderer_class(self.config)

        return renderer.render(report)

    def generate_from_api_response(
        self,
        api_response: Dict[str, Any],
        sequence: str,
        output_format: Optional[ReportFormat] = None,
    ) -> bytes:
        """Generate report from API response.

        Args:
            api_response: Response from the drug resistance API
            sequence: Original sequence
            output_format: Output format

        Returns:
            Report content as bytes
        """
        # Parse API response into DrugPrediction objects
        predictions = []

        # Handle drug_class_results format
        if "drug_class_results" in api_response:
            for drug_class, class_preds in api_response["drug_class_results"].items():
                for pred in class_preds:
                    predictions.append(DrugPrediction(
                        drug_name=pred.get("drug", "Unknown"),
                        drug_class=drug_class,
                        resistance_score=pred.get("resistance_score", 0.0),
                        classification=pred.get("interpretation", "").split(" - ")[0].lower(),
                        confidence=pred.get("confidence", 0.85),
                        mutations=pred.get("mutations_detected") or [],
                        interpretation=pred.get("interpretation", ""),
                    ))

        return self.generate(
            sequence=sequence,
            predictions=predictions,
            disease=api_response.get("disease", "HIV"),
            patient_id=api_response.get("patient_id"),
            recommended_drugs=api_response.get("recommended_drugs", []),
            avoid_drugs=api_response.get("avoid_drugs", []),
            warnings=api_response.get("cross_resistance_warnings", []),
            overall_recommendation=api_response.get("overall_recommendation", ""),
            output_format=output_format,
        )

    def save_report(
        self,
        content: bytes,
        filepath: Path,
        report_format: Optional[ReportFormat] = None,
    ) -> Path:
        """Save report to file.

        Args:
            content: Report content bytes
            filepath: Output file path
            report_format: Report format (used to add extension if needed)

        Returns:
            Path to saved file
        """
        output_path = Path(filepath)

        # Ensure correct extension
        format_extensions = {
            ReportFormat.HTML: ".html",
            ReportFormat.PDF: ".pdf",
            ReportFormat.JSON: ".json",
        }
        if report_format and output_path.suffix != format_extensions.get(report_format, ""):
            output_path = output_path.with_suffix(format_extensions.get(report_format, ".html"))

        # Create parent directories if needed
        output_path.parent.mkdir(parents=True, exist_ok=True)

        # Write content
        output_path.write_bytes(content)

        return output_path


# Archive management for report versioning
class ReportArchive:
    """Manage report archival and retrieval."""

    def __init__(self, archive_dir: Path):
        self.archive_dir = Path(archive_dir)
        self.archive_dir.mkdir(parents=True, exist_ok=True)
        self.index_file = self.archive_dir / "index.json"
        self._load_index()

    def _load_index(self):
        """Load the archive index."""
        if self.index_file.exists():
            self.index = json.loads(self.index_file.read_text())
        else:
            self.index = {"reports": []}

    def _save_index(self):
        """Save the archive index."""
        self.index_file.write_text(json.dumps(self.index, indent=2))

    def archive(
        self,
        report_id: str,
        content: bytes,
        patient_id: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> Path:
        """Archive a report.

        Args:
            report_id: Unique report identifier
            content: Report content
            patient_id: Patient identifier
            metadata: Additional metadata

        Returns:
            Path to archived report
        """
        # Create archive path
        date_prefix = datetime.now().strftime("%Y/%m/%d")
        archive_subdir = self.archive_dir / date_prefix
        archive_subdir.mkdir(parents=True, exist_ok=True)

        archive_path = archive_subdir / f"{report_id}.html"
        archive_path.write_bytes(content)

        # Update index
        self.index["reports"].append({
            "report_id": report_id,
            "patient_id": patient_id,
            "archived_at": datetime.now().isoformat(),
            "path": str(archive_path.relative_to(self.archive_dir)),
            "metadata": metadata or {},
        })
        self._save_index()

        return archive_path

    def retrieve(self, report_id: str) -> Optional[bytes]:
        """Retrieve an archived report.

        Args:
            report_id: Report identifier

        Returns:
            Report content or None if not found
        """
        for entry in self.index["reports"]:
            if entry["report_id"] == report_id:
                report_path = self.archive_dir / entry["path"]
                if report_path.exists():
                    return report_path.read_bytes()
        return None

    def list_reports(
        self,
        patient_id: Optional[str] = None,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None,
    ) -> List[Dict[str, Any]]:
        """List archived reports with optional filters.

        Args:
            patient_id: Filter by patient
            start_date: Filter by start date
            end_date: Filter by end date

        Returns:
            List of report entries
        """
        results = []
        for entry in self.index["reports"]:
            # Apply filters
            if patient_id and entry.get("patient_id") != patient_id:
                continue

            archived_at = datetime.fromisoformat(entry["archived_at"])
            if start_date and archived_at < start_date:
                continue
            if end_date and archived_at > end_date:
                continue

            results.append(entry)

        return results
